{"meta":{"title":"小站","subtitle":"","description":"","author":"凤歌","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Spring中的IOC","slug":"Spring中的IOC","date":"2021-05-28T12:29:17.000Z","updated":"2021-05-28T12:36:19.574Z","comments":true,"path":"2021/05/28/Spring中的IOC/","link":"","permalink":"http://example.com/2021/05/28/Spring%E4%B8%AD%E7%9A%84IOC/","excerpt":"","text":"二、 Spring 中的 IOC1. IOC 介绍按照维基百科，IoC（Inversion of Control）控制反转，是面向对象编程中的一种设计原则，用来降低计算机代码之间的耦合度。 在传统面向对象的编码过程中，当类与类之间存在依赖关系时，通常会直接在类的内部创建依赖对象，这样就导致类与类之间形成了耦合，依赖关系越复杂，耦合程度就会越高，而耦合度高的代码会非常难以进行修改和单元测试。而 IoC 则是专门提供一个容器进行依赖对象的创建和查找，将对依赖对象的控制权由类内部交到容器这里，这样就实现了类与类的解耦，保证所有的类都是可以灵活修改。 Spring中IOC IOC 的含义：Inversion Of Control，控制反转，指的是将 bean 对象的创建、对象关联关系的维护由原来我们自己去创建、自己去维护对象之间的关联关系，反转给 spring 的容器来创建并维护对象之间的关联关系。 IOC 的作用：解耦：解决了上层严重依赖下层的问题，实现了上层对下层的控制。 IOC 底层原理：xml 解析 + 反射 + 容器（HashMap） + 设计模式（单例） 2. Spring 获取 IOC 容器的三种方式 第一种：ClassPathXmlApplicationContext()：默认是去 src 目录下找配置文件 第二种：FileSystemXmlApplicationContext()：默认是去本地磁盘的具体位置去找对应的配置文件 第三种：XmlBeanFactory（已废弃） 注：一般使用第一种方式 3. 从容器中获取 bean 对象的两种方式及区别从容器中获取bean对象的两种方式在上一节，通过一个简单案例已经介绍过：从容器中获取bean对象 第一种：通过字节码的方式；第二种：通过容器中bean对象的id值或者name值的方式。 它们的区别有3个： 第一个：参数不同（一个是字符串类型，一个是字节码类型 ） 第二个：返回值类型不同（一个是Object类型，一个是我们自定义的类） 第三个：如果参数是字节码类型，要求容器中必须有该字节码类型的唯一bean对象，如果没有就会报错：NoSuchBeanDefinitionException；如果容器中有该类型的多个bean对象，会报错：NoUniqueBeanDefinitionException 。 4. 依赖注入（DI）DI 全称 Dependency Injection，它是控制反转的一种具体实现， DI与IOC的区别在于：IOC 是一种控制反转的思想，它的具体实现就是 DI 。在Java层面，说白了，IOC就是用来获取对象，DI就是给对象的属性赋值。 5. 容器中 bean 对象的创建时机、底层原理、是否单例创建时机：容器中的bean对象是在加载容器的时候创建的呢？还是从容器中获取bean对象的时候创建的 容器中的bean对象默认是在加载容器的时候，按着从上到下的顺序依次创建的。 底层原理: xml解析+反射+容器+设计模式 。 是否单例: 默认情况下，容器中的bean对象是单例的。 如果不想让它是单例的，可以修改bean标签的scope属性。scope属性取值会影响bean对象的创建时机和是否单例。scope有两个取值：singleton 和 prototype。 singleton（默认值）：单例的 prototype（需要手动设置）：多例的 6. 容器中配置Bean对象的三种方式容器中bean对象的三种创建方式 第一种：构造器（无参构造器、有参构造器） 第二种：静态工厂（通过类的静态方法得到的对象） 第三种：实例工厂（通过类对象的普通方法得到的对象） 配置文件 applicationContext.xml 123456789101112&lt;!--1.无参构造器 --&gt;&lt;bean class&#x3D;&quot;com.vieew.bean.User&quot;&gt;&lt;&#x2F;bean&gt;&lt;!--2.有参构造器 --&gt;&lt;bean class&#x3D;&quot;com.vieew.bean.User&quot;&gt; &lt;constructor-arg name&#x3D;&quot;id&quot; value&#x3D;&quot;1001&quot;&#x2F;&gt; &lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;马云&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;!-- 静态工厂:是指的通过类的静态方法得到的对象 --&gt;&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.vieew.bean.StaticFactory&quot; factory-method&#x3D;&quot;getUser&quot; &#x2F;&gt;&lt;!-- 实例工厂:是指的通过类对象的普通方法得到的对象--&gt;&lt;bean id&#x3D;&quot;instanceFactory&quot; class&#x3D;&quot;com.vieew.bean.InstanceFactory&quot; &#x2F;&gt;&lt;bean id&#x3D;&quot;user2&quot; factory-bean&#x3D;&quot;instanceFactory&quot; factory-method&#x3D;&quot;getUser&quot; &#x2F;&gt; JavaBean User.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class User &#123; private Integer id; private String name; private String pwd; public User() &#123; &#125; public User(Integer id, String name, String pwd) &#123; this.id = id; this.name = name; this.pwd = pwd; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 静态工厂 StaticFactory.java 12345public class StaticFactory &#123; public static User getUser() &#123; return new User(1002,&quot;马花&quot;); &#125;&#125; 实例工厂 InstanceFactory.java 12345public class InstanceFactory &#123; public static User getUser() &#123; return new User(1003,&quot;马力&quot;); &#125;&#125; 7. 给对象的属性赋值的三种方式第一种：通过有参构造器， 使用&lt;constructor-arg&gt;标签： name属性：构造器中参数的名字 value属性：表示设置的参数值 index属性：指定当前参数在构造器中的位置 type属性：指定当前参数的类型 结论：通过构造器给对象的属性赋值的时候， 我们可以通过构造器的 name、value、index、type 属性可以唯一的确定任何一个构造器 。 第二种：（1）通过set方法 （2）通过property标签 （3）通过p名称空间。 注：后两个本质上都是通过set方法赋值 第三种：使用注解的方式 （待后续补充 . . . . . .） 配置文件 applicationContext.xml 12345678910111213141516&lt;!-- 1.通过构造器的方式给对象的属性赋值 --&gt;&lt;bean class&#x3D;&quot;com.vieew.bean.Book&quot;&gt; &lt;constructor-arg name&#x3D;&quot;bid&quot; value&#x3D;&quot;101&quot; index&#x3D;&quot;1&quot; type&#x3D;&quot;java.lang.Integer&quot;&#x2F;&gt; &lt;constructor-arg name&#x3D;&quot;bookName&quot; value&#x3D;&quot;斗破苍穹&quot;&#x2F;&gt; &lt;constructor-arg name&#x3D;&quot;price&quot; value&#x3D;&quot;100.89&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;!-- 2.通过p标签(set方法)给对象的属性赋值 --&gt;&lt;bean id&#x3D;&quot;book1&quot; class&#x3D;&quot;com.vieew.bean.Book&quot; p:bid&#x3D;&quot;102&quot; p:bookName&#x3D;&quot;一剪没&quot; p:price&#x3D;&quot;32&quot;&#x2F;&gt;&lt;!-- 2.通过property标签(set方法)给对象的属性赋值 --&gt;&lt;bean id&#x3D;&quot;book1&quot; class&#x3D;&quot;com.vieew.bean.Book&quot;&gt; &lt;property name&#x3D;&quot;bid&quot; value&#x3D;&quot;110&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;bookName&quot; value&#x3D;&quot;Java从入门到放弃&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;price&quot; value&#x3D;&quot;30&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;","categories":[],"tags":[]},{"title":"初识spring","slug":"初识spring","date":"2017-05-28T10:20:29.000Z","updated":"2021-05-28T12:28:24.152Z","comments":true,"path":"2017/05/28/初识spring/","link":"","permalink":"http://example.com/2017/05/28/%E5%88%9D%E8%AF%86spring/","excerpt":"","text":"1. Spring简介Spring 是一个基于 IOC（控制反转）和 AOP（面向切面编程）的免费的、开源的、轻量级的、 Java 开发框架，用来简化企业项目的开发。 Spring 的官网：https://spring.io/projects/spring-framework 2. Spring在三层架构中的位置 3. Spring 的模块划分 根据上图可将Spring分成6个模块： Core (核心容器) AOP （面向切面） Instrumentation （为JVM添加代理） Data Access/Integration （数据访问与集成） Web （web和远程调用） Test （测试模块） 4. Spring 重要知识点梳理 注： 在实际的开发过程中，不必要引入所有的 Jar 包，只需要引入与自己项目相关的库就行。 5. Spring 第一个案例创建spring 第一个案例的流程大致如下： 第一步：创建动态 web 工程 第二步：导入 spring 的 jar 包 hamcrest-core-1.3.jar junit-4.12.jar commons-logging-1.2.jar spring-beans-5.3.6.jar spring-context-5.3.6.jar spring-core-5.3.6.jar spring-expression-5.3.6.jar 第三步：创建 spring 的配置文件 在类路径下创建配置文件：applicationContext.xml 第四步：创建一个 Person 类，并提供 gettere/setter 方法 第五步：在 spring 的配置文件中配置该类 第六步：从 spring 的容器（即配置文件 applicationContext.xml）中获取这个类对象 配置文件：applicationContext.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.vieew.pojo.User&quot;/&gt; &lt;/beans&gt; JavaBean：User.java 12345678910111213141516171819202122232425262728293031public class User &#123; private String name; private String pwd; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; public User() &#123; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 测试类 123456789101112@Testpublic void test() &#123; /** * 从spring的核心容器中获取person对象 */ //1.获取spring核心容器对象 ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //2.从容器对象中获取person对象 User bean = app.getBean(Person.class); //通过类名.class方式获取对象 //User bean = app.getBean(&quot;user&quot;); //通过配置文件里外部bean的id获取对象 System.out.println(bean); //看对象是否获取到了&#125;","categories":[],"tags":[]},{"title":"一些可能碰到的问题","slug":"一些可能碰到的问题","date":"2017-05-28T08:53:42.000Z","updated":"2021-05-28T12:28:08.523Z","comments":true,"path":"2017/05/28/一些可能碰到的问题/","link":"","permalink":"http://example.com/2017/05/28/%E4%B8%80%E4%BA%9B%E5%8F%AF%E8%83%BD%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"提交的问题hexo d后 ERROR Deployer not found: git 1npm install --save hexo-deployer-git 提交完成了 1Branch &#39;master&#39; set up to track remote branch &#39;master&#39; from ... md文件里插入图片如果插入的是网上的图片,大部分情况是可以显示的:比如 但是有些网址不给,比如语雀 - 专业的云端知识库 · 语雀 (yuque.com)](https://www.yuque.com/) 所以建议存到本地再上传,也可以避免不知道什么时候源文件丢失了 在根目录下配置文件_config.yml 中有 post_asset_folder:false改为true。这样在建立文件时，Hexo会自动建立一个与文章同名的文件夹，这样就可以把与该文章相关的所有资源（图片）都放到那个文件夹里方便后面引用。 git bash安装插件： 1npm install https:&#x2F;&#x2F;github.com&#x2F;7ym0n&#x2F;hexo-asset-image --save （这是个修改过的插件，经测试无问题），使用这个插件来引入图片，而不是网上那些方法里说的用传统md语法相对路径的方法。 插入图片时改变方式： md上传图片的语法是 1![img](https:&#x2F;&#x2F;ss2.bdstatic.com&#x2F;70cFvnSh_Q1YnxGkpoWK1HF6hhy&#x2F;it&#x2F;u&#x3D;2420744160,4087949052&amp;fm&#x3D;26&amp;gp&#x3D;0.jpg) 这样是没用的,需要改成 1&#123;% asset_img 此处为你的图片文件名.jpg 此处为你的图片描述 %&#125;","categories":[],"tags":[]},{"title":"从零开始搭建一个hexo博客","slug":"从零开始搭建一个hexo博客","date":"2017-05-28T07:35:53.000Z","updated":"2021-05-28T13:05:11.131Z","comments":true,"path":"2017/05/28/从零开始搭建一个hexo博客/","link":"","permalink":"http://example.com/2017/05/28/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAhexo%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"梦开始的地方安装hexo下载安装node.js利用npm下载cnpm 1npm install -g cnpm –registry&#x3D;[https:&#x2F;&#x2F;registy.npm.taobao.org](https:&#x2F;&#x2F;registy.npm.taobao.org&#x2F;) 用cnpm安装hexo 1cnpm install -g hexo-cli 可以用 1hexo -v 验证安装是否成功 建立blog建立blog文件夹 1mkdir blog hexo生成blog(初始化) 1hexo init 会看到如下提示信息 INFO Start blogging with Hexo! 启动1hexo s 新建会在source/_posts里面创建新的md文件 1hexo n “文章名字” 创建完成，进入路径里编辑了。编辑完保存 回到blog文件夹使用 1hexo clean 清理一下再 1hexo g 生成一下再 1hexo s 启动 部署到GitHub新建一个仓库名字必须是昵称.github.iodescription随便写 装一个插件1cnpm install –save hexo-deployer-git 设置_config.ymlblog下有一个_config.yml 打开-config.yml编辑它把最下面deploy：type:改成deploy:type: git（中间有个空格）repo: 仓库地址（中间有个空格）branch: master（中间有个空格）config修改完就部署到远端使用 1hexo d 验证github账号和密码，密码输入不会显示输入情况，输完直接回车就行 123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy: type: git repo: https:&#x2F;&#x2F;github.com&#x2F;ganansuan&#x2F;ganansuan.github.io branch: master 应用主题有个推荐的主题 1git clone https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia 会克隆到blog/themes文件夹里 继续修改_config.yml文件 把#Extensions里面的theme:landscaoe改成theme:yilia保存退出 1234# Extensions## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;theme: yilia 继续hexo clean&amp;hexo g&amp;hexo s&amp;hexo d 主题的配置:可以本地上传头像,图片的存放路径为blog\\themes\\yilia\\source\\图片名称.jpg","categories":[],"tags":[]}],"categories":[],"tags":[]}